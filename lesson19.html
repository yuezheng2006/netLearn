<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 19 讲 | HTTPDNS：网络世界的地址簿也会指错路 | 网络协议学习</title>
    <meta name="description" content="想成为技术牛人？先搞定网络协议">
    <link rel="icon" href="/netLearn/http.png">
  <link rel="manifest" href="/netLearn/manifest.json">
    
    <link rel="preload" href="/netLearn/assets/css/0.styles.b1407e59.css" as="style"><link rel="preload" href="/netLearn/assets/js/app.2914d2f8.js" as="script"><link rel="preload" href="/netLearn/assets/js/30.f727453f.js" as="script"><link rel="prefetch" href="/netLearn/assets/js/22.0ecb65f5.js"><link rel="prefetch" href="/netLearn/assets/js/1.2dde6845.js"><link rel="prefetch" href="/netLearn/assets/js/2.a4e6a5c5.js"><link rel="prefetch" href="/netLearn/assets/js/3.5c505085.js"><link rel="prefetch" href="/netLearn/assets/js/4.d1c55cea.js"><link rel="prefetch" href="/netLearn/assets/js/5.692adc04.js"><link rel="prefetch" href="/netLearn/assets/js/6.6eb18b6a.js"><link rel="prefetch" href="/netLearn/assets/js/7.a62cab1b.js"><link rel="prefetch" href="/netLearn/assets/js/8.a25bbd73.js"><link rel="prefetch" href="/netLearn/assets/js/9.779528af.js"><link rel="prefetch" href="/netLearn/assets/js/10.26371369.js"><link rel="prefetch" href="/netLearn/assets/js/11.e1058a42.js"><link rel="prefetch" href="/netLearn/assets/js/12.5b23976f.js"><link rel="prefetch" href="/netLearn/assets/js/13.40dd83ea.js"><link rel="prefetch" href="/netLearn/assets/js/14.07741444.js"><link rel="prefetch" href="/netLearn/assets/js/15.f60494a5.js"><link rel="prefetch" href="/netLearn/assets/js/16.f108ef2b.js"><link rel="prefetch" href="/netLearn/assets/js/17.a42a2cbd.js"><link rel="prefetch" href="/netLearn/assets/js/18.80fa4fa1.js"><link rel="prefetch" href="/netLearn/assets/js/19.cc5759a4.js"><link rel="prefetch" href="/netLearn/assets/js/20.586fd498.js"><link rel="prefetch" href="/netLearn/assets/js/21.d42138c5.js"><link rel="prefetch" href="/netLearn/assets/js/23.df13818e.js"><link rel="prefetch" href="/netLearn/assets/js/24.0e52a71a.js"><link rel="prefetch" href="/netLearn/assets/js/25.f4a9d0cc.js"><link rel="prefetch" href="/netLearn/assets/js/26.404f384a.js"><link rel="prefetch" href="/netLearn/assets/js/27.a863d69a.js"><link rel="prefetch" href="/netLearn/assets/js/28.d7cc877b.js"><link rel="prefetch" href="/netLearn/assets/js/29.b47ecaa2.js"><link rel="prefetch" href="/netLearn/assets/js/31.e9226cac.js"><link rel="prefetch" href="/netLearn/assets/js/32.c4045b97.js"><link rel="prefetch" href="/netLearn/assets/js/33.54de50f3.js"><link rel="prefetch" href="/netLearn/assets/js/34.c22e8566.js"><link rel="prefetch" href="/netLearn/assets/js/35.0fa76008.js"><link rel="prefetch" href="/netLearn/assets/js/36.93d1ec74.js"><link rel="prefetch" href="/netLearn/assets/js/37.86f84e99.js"><link rel="prefetch" href="/netLearn/assets/js/38.4e6aaa80.js"><link rel="prefetch" href="/netLearn/assets/js/39.83d0b4af.js"><link rel="prefetch" href="/netLearn/assets/js/40.85e9fe2d.js"><link rel="prefetch" href="/netLearn/assets/js/41.c18e2cc3.js"><link rel="prefetch" href="/netLearn/assets/js/42.a37c9de2.js"><link rel="prefetch" href="/netLearn/assets/js/43.f8744481.js"><link rel="prefetch" href="/netLearn/assets/js/44.f0b6384a.js"><link rel="prefetch" href="/netLearn/assets/js/45.fbf3d342.js">
    <link rel="stylesheet" href="/netLearn/assets/css/0.styles.b1407e59.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/netLearn/" class="home-link router-link-active"><!----> <span class="site-name">网络协议学习</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/netLearn/" class="nav-link">首页</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/netLearn/" class="nav-link">首页</a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>网络协议课程</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/netLearn/intro.html" class="sidebar-link">前言</a></li><li><a href="/netLearn/lesson1.html" class="sidebar-link">为什么要学习网络协议</a></li><li><a href="/netLearn/lesson2.html" class="sidebar-link">网络分层的真实含义</a></li><li><a href="/netLearn/lesson3.html" class="sidebar-link">ifconfig命令</a></li><li><a href="/netLearn/lesson4.html" class="sidebar-link">DHCP和PXE</a></li><li><a href="/netLearn/lesson5.html" class="sidebar-link">从物理层到MAC层</a></li><li><a href="/netLearn/lesson6.html" class="sidebar-link">交换机与VLAN</a></li><li><a href="/netLearn/lesson7.html" class="sidebar-link">ICMP与ping</a></li><li><a href="/netLearn/lesson8.html" class="sidebar-link">世界那么大，我想出网关</a></li><li><a href="/netLearn/lesson9.html" class="sidebar-link">路由协议</a></li><li><a href="/netLearn/lesson10.html" class="sidebar-link">UDP协议</a></li><li><a href="/netLearn/lesson11.html" class="sidebar-link">TCP协议上</a></li><li><a href="/netLearn/lesson12.html" class="sidebar-link">TCP协议下</a></li><li><a href="/netLearn/lesson13.html" class="sidebar-link">套接字</a></li><li><a href="/netLearn/lesson14.html" class="sidebar-link">http协议</a></li><li><a href="/netLearn/lesson15.html" class="sidebar-link">https协议</a></li><li><a href="/netLearn/lesson16.html" class="sidebar-link">流媒体协议</a></li><li><a href="/netLearn/lesson17.html" class="sidebar-link">P2P协议</a></li><li><a href="/netLearn/lesson18.html" class="sidebar-link">DNS协议</a></li><li><a href="/netLearn/lesson19.html" class="active sidebar-link">HTTPDNS</a></li><li><a href="/netLearn/lesson20.html" class="sidebar-link">CDN</a></li><li><a href="/netLearn/lesson21.html" class="sidebar-link">数据中心</a></li><li><a href="/netLearn/lesson22.html" class="sidebar-link">VPN</a></li><li><a href="/netLearn/lesson23.html" class="sidebar-link">移动网络</a></li><li><a href="/netLearn/lesson24.html" class="sidebar-link">云中网络</a></li><li><a href="/netLearn/lesson25.html" class="sidebar-link">软件定义网络</a></li><li><a href="/netLearn/lesson26.html" class="sidebar-link">云中的网络安全</a></li><li><a href="/netLearn/lesson27.html" class="sidebar-link">云中的网络 QoS</a></li><li><a href="/netLearn/lesson28.html" class="sidebar-link">云中网络的隔离</a></li><li><a href="/netLearn/lesson29.html" class="sidebar-link">容器网络</a></li><li><a href="/netLearn/lesson30.html" class="sidebar-link">容器网络之Flannel</a></li><li><a href="/netLearn/lesson31.html" class="sidebar-link">容器网络之Calico</a></li><li><a href="/netLearn/lesson32.html" class="sidebar-link">RPC协议综述</a></li><li><a href="/netLearn/lesson33.html" class="sidebar-link">基于XML的SOAP协议</a></li><li><a href="/netLearn/lesson34.html" class="sidebar-link">基于JSON的RESTful接口协议</a></li><li><a href="/netLearn/lesson35.html" class="sidebar-link">二进制类RPC协议</a></li><li><a href="/netLearn/lesson36.html" class="sidebar-link">跨语言类 RPC 协议</a></li><li><a href="/netLearn/lesson37.html" class="sidebar-link">知识串讲：用双十一的故事串起碎片的网络协议（上）</a></li><li><a href="/netLearn/lesson38.html" class="sidebar-link">知识串讲：用双十一的故事串起碎片的网络协议（中）</a></li><li><a href="/netLearn/lesson39.html" class="sidebar-link">知识串讲：用双十一的故事串起碎片的网络协议（下）</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="第-19-讲-httpdns：网络世界的地址簿也会指错路"><a href="#第-19-讲-httpdns：网络世界的地址簿也会指错路" aria-hidden="true" class="header-anchor">#</a> 第 19 讲 | HTTPDNS：网络世界的地址簿也会指错路</h1> <blockquote><p>2018-06-29 刘超</p></blockquote> <!----> <p>上一节我们知道了 DNS 的两项功能，第一是根据名称查到具体的地址，另外一个是可以针对多个地址做负载均衡，而且可以在多个地址中选择一个距离你近的地方访问。</p> <p>然而有时候这个地址簿也经常给你指错路，明明距离你 500 米就有个吃饭的地方，非要把你推荐到 5 公里外。为什么会出现这样的情况呢？</p> <p>还记得吗？当我们发出请求解析 DNS 的时候，首先，会先连接到运营商本地的 DNS 服务器，由这个服务器帮我们去整棵 DNS 树上进行解析，然后将解析的结果返回给客户端。但是本地的 DNS 服务器，作为一个本地导游，往往有自己的“小心思”。</p> <h2 id="传统-dns-存在哪些问题？"><a href="#传统-dns-存在哪些问题？" aria-hidden="true" class="header-anchor">#</a> 传统 DNS 存在哪些问题？</h2> <h3 id="_1-域名缓存问题"><a href="#_1-域名缓存问题" aria-hidden="true" class="header-anchor">#</a> 1. 域名缓存问题</h3> <p>它可以在本地做一个缓存，也就是说，不是每一个请求，它都会去访问权威 DNS 服务器，而是访问过一次就把结果缓存到自己本地，当其他人来问的时候，直接就返回这个缓存数据。</p> <p>这就相当于导游去过一个饭店，自己脑子记住了地址，当有一个游客问的时候，他就凭记忆回答了，不用再去查地址簿。这样经常存在的一个问题是，人家那个饭店明明都已经搬了，结果作为导游，他并没有刷新这个缓存，结果你辛辛苦苦到了这个地点，发现饭店已经变成了服装店，你是不是会非常失望？</p> <p>另外，有的运营商会把一些静态页面，缓存到本运营商的服务器内，这样用户请求的时候，就不用跨运营商进行访问，这样既加快了速度，也减少了运营商之间流量计算的成本。在域名解析的时候，不会将用户导向真正的网站，而是指向这个缓存的服务器。</p> <p>很多情况下是看不出问题的，但是当页面更新，用户会访问到老的页面，问题就出来了。例如，你听说一个餐馆推出了一个新菜，你想去尝一下。结果导游告诉你，在这里吃也是一样的。有的游客会觉得没问题，但是对于想尝试新菜的人来说，如果导游说带你去，但其实并没有吃到新菜，你是不是也会非常失望呢？</p> <p>再就是本地的缓存，往往使得全局负载均衡失败，因为上次进行缓存的时候，缓存中的地址不一定是这次访问离客户最近的地方，如果把这个地址返回给客户，那肯定就会绕远路。</p> <p>就像上一次客户要吃西湖醋鱼的事，导游知道西湖边有一家，因为当时游客就在西湖边，可是，下一次客户在灵隐寺，想吃西湖醋鱼的时候，导游还指向西湖边的那一家，那这就绕的太远了。
<!----></p> <h3 id="_2-域名转发问题"><a href="#_2-域名转发问题" aria-hidden="true" class="header-anchor">#</a> 2. 域名转发问题</h3> <p>缓存问题还是说本地域名解析服务，还是会去权威 DNS 服务器中查找，只不过不是每次都要查找。可以说这还是大导游、大中介。还有一些小导游、小中介，有了请求之后，直接转发给其他运营商去做解析，自己只是外包了出去。</p> <p>这样的问题是，如果是 A 运营商的客户，访问自己运营商的 DNS 服务器，如果 A 运营商去权威 DNS 服务器查询的话，权威 DNS 服务器知道你是 A 运营商的，就返回给一个部署在 A 运营商的网站地址，这样针对相同运营商的访问，速度就会快很多。</p> <p>但是 A 运营商偷懒，将解析的请求转发给 B 运营商，B 运营商去权威 DNS 服务器查询的话，权威服务器会误认为，你是 B 运营商的，那就返回给你一个在 B 运营商的网站地址吧，结果客户的每次访问都要跨运营商，速度就会很慢。</p> <!----> <h3 id="_3-出口-nat-问题"><a href="#_3-出口-nat-问题" aria-hidden="true" class="header-anchor">#</a> 3. 出口 NAT 问题</h3> <p>前面讲述网关的时候，我们知道，出口的时候，很多机房都会配置 NAT，也即网络地址转换，使得从这个网关出去的包，都换成新的 IP 地址，当然请求返回的时候，在这个网关，再将 IP 地址转换回去，所以对于访问来说是没有任何问题。</p> <p>但是一旦做了网络地址的转换，权威的 DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问。</p> <h3 id="_4-域名更新问题"><a href="#_4-域名更新问题" aria-hidden="true" class="header-anchor">#</a> 4. 域名更新问题</h3> <p>本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的 TTL 时间限制，在权威 DNS 服务器解析变更的时候，解析结果在全网生效的周期非常漫长。但是有的时候，在 DNS 的切换中，场景对生效时间要求比较高。</p> <p>例如双机房部署的时候，跨机房的负载均衡和容灾多使用 DNS 来做。当一个机房出问题之后，需要修改权威 DNS，将域名指向新的 IP 地址，但是如果更新太慢，那很多用户都会出现访问异常。</p> <p>这就像，有的导游比较勤快、敬业，时时刻刻关注酒店、餐馆、交通的变化，问他的时候，往往会得到最新情况。有的导游懒一些，8 年前背的导游词就没换过，问他的时候，指的路往往就是错的。</p> <h4 id="_5-解析延迟问题"><a href="#_5-解析延迟问题" aria-hidden="true" class="header-anchor">#</a> 5. 解析延迟问题</h4> <p>从上一节的 DNS 查询过程来看，DNS 的查询过程需要递归遍历多个 DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。</p> <h2 id="httpdns-的工作模式"><a href="#httpdns-的工作模式" aria-hidden="true" class="header-anchor">#</a> HTTPDNS 的工作模式</h2> <p>既然 DNS 解析中有这么多问题，那怎么办呢？难不成退回到直接用 IP 地址？这样显然不合适，所以就有了 HTTPDNS。</p> <p><strong>HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。</strong></p> <p>这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走 DNS 的，因而使用 HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端。使用 HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持 HTTPDNS 的客户端 SDK。</p> <p>通过自己的 HTTPDNS 服务器和自己的 SDK，实现了从依赖本地导游，到自己上网查询做旅游攻略，进行自由行，爱怎么玩怎么玩。这样就能够避免依赖导游，而导游又不专业，你还不能把他怎么样的尴尬。</p> <p>下面我来解析一下 <strong>HTTPDNS 的工作模式</strong>。</p> <p>在客户端的 SDK 里动态请求服务端，获取 HTTPDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果。</p> <p>当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己做的，而非整个运营商统一做的。如何更新、何时更新，手机应用的客户端可以和服务器协调来做这件事情。</p> <p>如果本地没有，就需要请求 HTTPDNS 的服务器，在本地 HTTPDNS 服务器的 IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网站的 IP 列表。</p> <p>请求的方式是这样的。</p> <div class="language-sh extra-class"><pre class="language-text"><code>curl http://106.2.xxx.xxx/d?dn=c.m.163.com
{&quot;dns&quot;:[{&quot;host&quot;:&quot;c.m.163.com&quot;,&quot;ips&quot;:[&quot;223.252.199.12&quot;],&quot;ttl&quot;:300,&quot;http2&quot;:0}],&quot;client&quot;:{&quot;ip&quot;:&quot;106.2.81.50&quot;,&quot;line&quot;:269692944}}
</code></pre></div><p>手机客户端自然知道手机在哪个运营商、哪个地址。由于是直接的 HTTP 通信，HTTPDNS 服务器能够准确知道这些信息，因而可以做精准的全局负载均衡。
<!----></p> <p>当然，当所有这些都不工作的时候，可以切换到传统的 LocalDNS 来解析，慢也比访问不到好。那 HTTPDNS 是如何解决上面的问题的呢？</p> <p>其实归结起来就是两大问题。一是解析速度和更新速度的平衡问题，二是智能调度的问题，对应的解决方案是 HTTPDNS 的缓存设计和调度设计。</p> <h2 id="httpdns-的缓存设计"><a href="#httpdns-的缓存设计" aria-hidden="true" class="header-anchor">#</a> HTTPDNS 的缓存设计</h2> <p>解析 DNS 过程复杂，通信次数多，对解析速度造成很大影响。为了加快解析，因而有了缓存，但是这又会产生缓存更新速度不及时的问题。最要命的是，这两个方面都掌握在别人手中，也即本地 DNS 服务器手中，它不会为你定制，你作为客户端干着急没办法。</p> <p>而 HTTPDNS 就是将解析速度和更新速度全部掌控在自己手中。一方面，解析的过程，不需要本地 DNS 服务递归的调用一大圈，一个 HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可以自己控制。</p> <p>HTTPDNS 的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层。</p> <ul><li><p>对于应用架构来讲，就是应用、缓存、数据库。常见的是 Tomcat、Redis、MySQL。</p></li> <li><p>对于 HTTPDNS 来讲，就是手机客户端、DNS 缓存、HTTPDNS 服务器。
<!----></p></li></ul> <p>只要是缓存模式，就存在缓存的过期、更新、不一致的问题，解决思路也是很像的。</p> <p>例如 DNS 缓存在内存中，也可以持久化到存储上，从而 APP 重启之后，能够尽快从存储中加载上次累积的经常访问的网站的解析结果，就不需要每次都全部解析一遍，再变成缓存。这有点像 Redis 是基于内存的缓存，但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。</p> <p>SDK 中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。</p> <p>解析可以 <strong>同步进行</strong>，也就是直接调用 HTTPDNS 的接口，返回最新的记录，更新缓存；也可以异步进行，添加一个解析任务到后台，由后台任务调用 HTTPDNS 的接口。</p> <p>同步更新的优点是实时性好，缺点是如果有多个请求都发现过期的时候，同时会请求 HTTPDNS 多次，其实是一种浪费。</p> <p>同步更新的方式对应到应用架构中缓存的 <strong>Cache-Aside 机制</strong>，也即先读缓存，不命中读数据库，同时将结果写入缓存。</p> <!----> <p><strong>异步更新</strong>的优点是，可以将多个请求都发现过期的情况，合并为一个对于 HTTPDNS 的请求任务，只执行一次，减少 HTTPDNS 的压力。同时可以在即将过期的时候，就创建一个任务进行预加载，防止过期之后再刷新，称为 <strong>预加载</strong>。</p> <p>它的缺点是当前请求拿到过期数据的时候，如果客户端允许使用过期数据，需要冒一次风险。如果过期的数据还能请求，就没问题；如果不能请求，则失败一次，等下次缓存更新后，再请求方能成功。
<!----></p> <p>异步更新的机制对应到应用架构中缓存的 Refresh-Ahead 机制，即业务仅仅访问缓存，当过期的时候定期刷新。在著名的应用缓存 Guava Cache 中，有个 RefreshAfterWrite 机制，对于并发情况下，多个缓存访问不命中从而引发并发回源的情况，可以采取只有一个请求回源的模式。在应用架构的缓存中，也常常用数据预热或者预加载的机制。
<!----></p> <h2 id="httpdns-的调度设计"><a href="#httpdns-的调度设计" aria-hidden="true" class="header-anchor">#</a> HTTPDNS 的调度设计</h2> <p>由于客户端嵌入了 SDK，因而就不会因为本地 DNS 的各种缓存、转发、NAT，让权威 DNS 服务器误会客户端所在的位置和运营商，而可以拿到第一手资料。</p> <p>在 <strong>客户端</strong>，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS 服务端可以根据这些信息，选择最佳的服务节点返回。</p> <p>如果有多个节点，还会考虑错误率、请求时间、服务器压力、网络状况等，进行综合选择，而非仅仅考虑地理位置。当有一个节点宕机或者性能下降的时候，可以尽快进行切换。</p> <p>要做到这一点，需要客户端使用 HTTPDNS 返回的 IP 访问业务应用。客户端的 SDK 会收集网络请求数据，如错误率、请求时间等网络请求质量数据，并发送到统计后台，进行分析、聚合，以此查看不同的 IP 的服务质量。</p> <p>在服务端，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。</p> <p>HTTPDNS 通过智能调度之后返回的结果，也会缓存在客户端。为了不让缓存使得调度失真，客户端可以根据不同的移动网络运营商 WIFI 的 SSID 来分维度缓存。不同的运营商或者 WIFI 解析出来的结果会不同。</p> <!----> <h2 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结</h2> <p>好了，这节就到这里了，我们来总结一下，你需要记住这两个重点：</p> <ul><li><p>传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。</p></li> <li><p>HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。</p></li></ul> <p>最后，给你留两个思考题。</p> <ol><li><p>使用 HTTPDNS，需要向 HTTPDNS 服务器请求解析域名，可是客户端怎么知道 HTTPDNS 服务器的地址或者域名呢？</p></li> <li><p>HTTPDNS 的智能调度，主要是让客户端选择最近的服务器，而有另一种机制，使得资源分发到离客户端更近的位置，从而加快客户端的访问，你知道是什么技术吗？</p></li></ol></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/netLearn/lesson18.html" class="prev">
          DNS协议
        </a></span> <span class="next"><a href="/netLearn/lesson20.html">
          CDN
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/netLearn/assets/js/30.f727453f.js" defer></script><script src="/netLearn/assets/js/app.2914d2f8.js" defer></script>
  </body>
</html>
